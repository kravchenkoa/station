profile = "speech/synthesis@1.0"
provider = "ibm-cloud"

map TextToSpeechSynthesis {
  http POST "/instances/{input.instance}/v1/synthesize" {
    security "basic"
    request {
      headers {
        Accept = call mapEncodingToMimeType(audio = input.audio)
        Voice = call mapVoiceOptioinsToVoiceHeaderValue(voice = input.voice)
      }
      body {
        text = input.text
      }
    }

    response 200 {
      audioContent = call base64Encode(input = body)
      map result {
        audioContent = audioContent
      }
    }

  }
}

operation mapEncodingToMimeType {
  rate = args.audio.sampleRateHertz

  set {
    result = (() => {
      switch (args.audio.encoding) {
        case 'mp3':
          if(!rate) rate = 22050
          return 'audio/mp3;rate=' + rate

        case 'linear_pcm':
        if(!rate) rate = 8000
          return 'audio/wav;rate=' + rate

        default:
          return 'audio/wav'
      }
    })()
  }

  return result
}

operation mapVoiceOptioinsToVoiceHeaderValue {
  return args.voice.languageCode + '_' + args.voice.name
}

"TODO: fix ecoding"
operation base64Encode {
  set {
      result = (() => {

      const utf8_encode = string => {
        string = string.replace('\r\n', '\n');
        let utftext = '';

        for (let n = 0; n < string.length; n++) {
          let c = string.charCodeAt(n);

          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if (c > 127 && c < 2048) {
            utftext += String.fromCharCode((c >> 6) | 192);
            utftext += String.fromCharCode((c & 63) | 128);
          } else {
            utftext += String.fromCharCode((c >> 12) | 224);
            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
            utftext += String.fromCharCode((c & 63) | 128);
          }
        }
        return utftext;
      };

      const _keyStr =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

      let input;
      let output = '';
      let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      let i = 0;
      
      input = utf8_encode(args.input.toString());

      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }

        output =
          output +
          _keyStr.charAt(enc1) +
          _keyStr.charAt(enc2) +
          _keyStr.charAt(enc3) +
          _keyStr.charAt(enc4);
      }

      return output;
    })()
  }

  return result
}
